import Foundation

// MARK: - TEACHING: Swift Data Models
/// Data models in Swift are typically structs, not classes.
///
/// STRUCT VS CLASS:
/// - Struct: Value type, copied when assigned, immutable by default
/// - Class: Reference type, shared when assigned, mutable
///
/// USE STRUCTS FOR:
/// - Data models (like Note)
/// - Small, self-contained values
/// - When you want thread safety (value types are inherently thread-safe)
///
/// USE CLASSES FOR:
/// - When you need identity (same instance, not just same values)
/// - When you need inheritance
/// - For services and state containers (ObservableObject requires class)
///
/// REACT/JS COMPARISON:
/// In JS, objects are always reference types. You'd use Object.freeze()
/// or libraries like Immer for immutability. In Swift, structs give you
/// immutability by default.
struct Note: Codable, Identifiable, Equatable {

    // MARK: - Properties

    /// Unique identifier for the note.
    /// TEACHING: In production with Amplify, this would be generated by AppSync/DynamoDB.
    let id: String

    /// Note title (required)
    let title: String

    /// Note content/body (optional but defaults to empty)
    let content: String

    /// When the note was created
    let createdAt: Date

    /// When the note was last modified
    let updatedAt: Date

    // MARK: - TEACHING: Identifiable Protocol

    /// The Identifiable protocol requires an `id` property.
    /// This is used by SwiftUI's ForEach and List to track items.
    /// Without it, SwiftUI can't efficiently diff and update lists.
    ///
    /// REACT COMPARISON:
    /// This is like the `key` prop in React lists.
    /// SwiftUI uses `id` to know which items changed, were added, or removed.

    // MARK: - TEACHING: Equatable Protocol

    /// Equatable allows comparing two Notes with ==
    /// Swift auto-synthesizes this for structs where all properties are Equatable.
    /// This is used by SwiftUI to check if a view needs to re-render.

    // MARK: - TEACHING: Codable Protocol

    /// Codable = Encodable + Decodable
    /// The compiler automatically generates JSON encoding/decoding
    /// because all our properties are themselves Codable (String, Date).
    ///
    /// For custom date formats, use:
    /// - decoder.dateDecodingStrategy = .iso8601
    /// - encoder.dateEncodingStrategy = .iso8601

    // MARK: - Convenience Initializer

    /// Default initializer with sensible defaults.
    init(
        id: String = UUID().uuidString,
        title: String,
        content: String = "",
        createdAt: Date = Date(),
        updatedAt: Date = Date()
    ) {
        self.id = id
        self.title = title
        self.content = content
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

// MARK: - TEACHING: Extensions

/// Extensions allow adding functionality to existing types.
/// This keeps the main type definition clean and focused on data.
extension Note {

    /// Formatted date string for display.
    /// TEACHING: Computed properties in extensions are a common pattern.
    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: updatedAt)
    }

    /// Preview truncated content.
    var contentPreview: String {
        if content.isEmpty {
            return "No content"
        }
        let maxLength = 100
        if content.count <= maxLength {
            return content
        }
        return String(content.prefix(maxLength)) + "..."
    }
}

// MARK: - Sample Data for Previews

/// TEACHING: Static sample data for SwiftUI Previews.
/// This allows you to design views without a running backend.
extension Note {
    static let samples: [Note] = [
        Note(
            title: "Meeting Notes",
            content: "Discussed Q1 roadmap and engineering priorities. Key decisions: move to GraphQL, adopt Amplify for auth.",
            createdAt: Date().addingTimeInterval(-86400),
            updatedAt: Date().addingTimeInterval(-3600)
        ),
        Note(
            title: "Ideas",
            content: "Feature ideas for next sprint: dark mode, offline sync, push notifications.",
            createdAt: Date().addingTimeInterval(-172800),
            updatedAt: Date().addingTimeInterval(-172800)
        ),
        Note(
            title: "Learning Swift",
            content: "Key concepts: value vs reference types, optionals, property wrappers, async/await.",
            createdAt: Date().addingTimeInterval(-259200),
            updatedAt: Date().addingTimeInterval(-86400)
        )
    ]

    static let sample = samples[0]
}
